/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ProjectTasks
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// helpers.ts
var BLOCK_BOUNDARY = /^#+\s/;
var DEBUG = true;
var DEFAULT_SETTINGS = {
  idPrefixMethod: "1" /* UsePrefix */,
  projectPrefix: "prj",
  randomIDLength: 6,
  sequentialStartNumber: 1,
  removeVowels: false,
  firstLettersOfWords: false,
  automaticTagNames: ["Project"],
  clearAllTags: false,
  nestedTaskBehavior: "1" /* ParallelExecution */
};
var ParsedLine = class {
  constructor(is_task, status_type, line_text, nesting) {
    this.is_task = is_task;
    this.status_type = status_type;
    this.line_text = line_text;
    this.nesting = nesting;
    if (this.is_task) {
      let indents = "	".repeat(nesting);
      this.task_prefix = `${indents}- [${status_type}] `;
    } else {
      this.task_prefix = "";
    }
  }
  getLineSplit(line) {
    return line.split(/(\s+)/);
  }
  removeAllTags() {
    return this.removeTags();
  }
  removeTags(tags_to_remove) {
    let words = this.getLineSplit(this.line_text);
    for (let idx = 0; idx < words.length; idx++) {
      let word = words[idx];
      if (word.trim().length != 0) {
        let is_valid_tag = word.startsWith("#") && (!tags_to_remove || tags_to_remove.indexOf(word.slice(1)) >= 0);
        if (is_valid_tag) {
          words[idx] = "";
          if (idx != 0) {
            words[idx - 1] = "";
          } else if (idx != words.length - 1) {
            words[idx + 1] = "";
          }
        }
      } else {
        if (idx == words.length - 1) {
          words[idx] = "";
        }
      }
    }
    return words.join("");
  }
};
var Helper = class {
  // Simple helper class that contains the business logic
  // of the app. This is extracted here to allow unit testing
  constructor() {
  }
  static getNestingLevel(task_marker) {
    let parts = task_marker.replaceAll("\n", "").split("-");
    return parts[0].length;
  }
  static generateRandomDigits(length) {
    const digits = "0123456789";
    let randomString = "";
    for (let i = 0; i < length; i++) {
      const randomIndex = Math.floor(Math.random() * digits.length);
      randomString += digits[randomIndex];
    }
    return randomString;
  }
  static clearBlockIDs(sel, automatic_tags, clear_all_tags) {
    let remove_id = /ðŸ†”\s[\w,]+[ \t]*/g;
    sel = sel.replaceAll(remove_id, "");
    let remove_block = /â›”\s[\w,]+[ \t]*/g;
    sel = sel.replaceAll(remove_block, "");
    let cleaned_text = [];
    for (let line of sel.split(/\r?\n/)) {
      let parsed = this.parseLine(line);
      if (parsed.is_task) {
        if (clear_all_tags) {
          cleaned_text.push(parsed.task_prefix + parsed.removeAllTags());
        } else {
          cleaned_text.push(parsed.task_prefix + parsed.removeTags(automatic_tags));
        }
      } else {
        cleaned_text.push(parsed.line_text);
      }
    }
    return cleaned_text.join("\n");
  }
  static getBlockEnd(editor) {
    let blockEnd = editor.getCursor().line;
    if (blockEnd >= editor.lineCount() - 1)
      return blockEnd + 1;
    blockEnd += 1;
    while (!BLOCK_BOUNDARY.test(editor.getLine(blockEnd))) {
      blockEnd++;
      if (blockEnd > editor.lineCount() - 1)
        return blockEnd;
    }
    return blockEnd;
  }
  static getBlockStart(editor) {
    let blockStart = editor.getCursor().line;
    if (BLOCK_BOUNDARY.test(editor.getLine(blockStart))) {
      return Math.min(editor.lineCount() - 1, blockStart + 1);
    }
    while (blockStart > 0 && !BLOCK_BOUNDARY.test(editor.getLine(blockStart - 1))) {
      blockStart--;
    }
    return blockStart;
  }
  static getAllBlockStarts(editor) {
    let blocks = [0];
    let section = /^#?\s\w+/;
    for (let line_number = 0; line_number < editor.lineCount(); line_number++) {
      if (section.test(editor.getLine(line_number))) {
        if (line_number > 0) {
          blocks.push(line_number);
        }
      }
    }
    return blocks;
  }
  static getSectionName(editor, file_name) {
    let section_start = Helper.getBlockStart(editor);
    if (section_start == 0) {
      return file_name;
    } else {
      return editor.getLine(section_start - 1);
    }
  }
  static addTaskIDs(sel, prefix, automatic_tags, parallel, use_prefix, random_id_length, sequential_start) {
    sel = Helper.clearBlockIDs(sel, automatic_tags, false);
    if (DEBUG)
      console.log(`Replaced ids and blocks to give: ${sel}`);
    let lines = "";
    let first = true;
    let idx = 0;
    let nesting_ids = ["0:ERROR!"];
    let current_nesting = 0;
    let is_parallel = false;
    let this_id;
    for (const line of sel.split(/\r?\n/)) {
      let match = this.parseLine(line);
      if (!first) {
        lines += "\n";
      }
      if (match.is_task) {
        if (parallel) {
          let nesting_depth = match.nesting;
          if (nesting_depth > current_nesting) {
            current_nesting += 1;
            is_parallel = true;
            nesting_ids.push(``);
          } else if (nesting_depth < current_nesting) {
            while (current_nesting > nesting_depth) {
              current_nesting -= 1;
              let nested = nesting_ids.pop();
              if (nested) {
                nesting_ids[nesting_ids.length - 1] += `,${nested}`;
              }
              is_parallel = current_nesting > 0;
            }
          }
        }
        let this_line;
        if (use_prefix) {
          this_id = `${prefix}${Helper.generateRandomDigits(random_id_length)}`;
        } else {
          this_id = `${prefix}${idx + sequential_start}`;
        }
        let cleaned_line = match.line_text;
        if (cleaned_line != "")
          cleaned_line += " ";
        this_line = `${match.task_prefix}${cleaned_line}\u{1F194} ${this_id}`;
        if (idx > 0) {
          if (is_parallel) {
            this_line += ` \u26D4 ${nesting_ids[current_nesting - 1]}`;
          } else {
            this_line += ` \u26D4 ${nesting_ids[nesting_ids.length - 1]}`;
          }
        }
        for (const tag of automatic_tags) {
          let tag_text = ` #${tag}`;
          if (this_line.indexOf(tag_text) < 0) {
            this_line += tag_text;
          }
        }
        lines += this_line;
        idx += 1;
        if (is_parallel) {
          if (nesting_ids[nesting_ids.length - 1])
            nesting_ids[nesting_ids.length - 1] += ",";
          nesting_ids[nesting_ids.length - 1] += `${this_id}`;
        } else {
          nesting_ids[nesting_ids.length - 1] = this_id;
        }
        if (DEBUG)
          console.log(`Nesting level ${current_nesting}, ids ${nesting_ids}`);
      } else {
        lines += match.line_text;
      }
      first = false;
    }
    return lines;
  }
  static blockUpdate(editor, filename, add_ids, settings) {
    const prefix = this.getPrefix(editor, filename, settings);
    const line = editor.getLine(editor.getCursor().line);
    let blockStart = Helper.getBlockStart(editor);
    let blockEnd = Helper.getBlockEnd(editor);
    let last_line_length = editor.getLine(blockEnd + 1).length;
    const blockContent = editor.getRange({ line: blockStart, ch: 0 }, { line: blockEnd, ch: last_line_length });
    if (DEBUG)
      console.log(`Start ${blockStart}, End ${blockEnd}, last length ${last_line_length}
Orig: ${blockContent}`);
    let lines;
    if (add_ids) {
      lines = Helper.addTaskIDs(
        blockContent,
        prefix,
        settings.automaticTagNames,
        settings.nestedTaskBehavior == "1" /* ParallelExecution */,
        settings.idPrefixMethod == "1" /* UsePrefix */,
        settings.randomIDLength,
        settings.sequentialStartNumber
      );
    } else {
      lines = Helper.clearBlockIDs(
        blockContent,
        settings.automaticTagNames,
        settings.clearAllTags
      );
    }
    if (DEBUG)
      console.log(`Start ${blockStart}, End ${blockEnd}, last length ${last_line_length}
Orig: ${blockContent}
New: ${lines}`);
    editor.replaceRange(lines, { line: blockStart, ch: 0 }, { line: blockEnd, ch: last_line_length });
  }
  static getEntireConvertedFile(editor, filename, settings) {
    let initial_cursor = editor.getCursor();
    for (let block_start of this.getAllBlockStarts(editor)) {
      editor.setCursor({ line: block_start, ch: 0 });
      this.blockUpdate(editor, filename, true, settings);
    }
    editor.setCursor({ line: initial_cursor.line, ch: initial_cursor.ch });
  }
  static parseLine(line) {
    const regex = /^(\s*-\s\[([ x\-\/])\]\s)?(.*)$/;
    let match = regex.exec(line);
    if (match) {
      if (match[1]) {
        return new ParsedLine(true, match[2], match[3], this.getNestingLevel(line));
      } else {
        return new ParsedLine(false, "", match[3], 0);
      }
    } else {
      throw new Error(`Line was not understood: "${line}"`);
    }
  }
  static getPrefix(editor, filename, settings) {
    let raw_prefix;
    switch (settings.idPrefixMethod) {
      case "1" /* UsePrefix */: {
        raw_prefix = settings.projectPrefix;
        break;
      }
      case "3" /* FileName */: {
        raw_prefix = filename;
        break;
      }
      case "2" /* SectionName */: {
        raw_prefix = Helper.getSectionName(editor, filename);
      }
    }
    return Helper.getPrefixFromString(raw_prefix, settings.firstLettersOfWords, settings.removeVowels);
  }
  static getPrefixFromString(text, first_letters, remove_vowels) {
    text = text.replaceAll(/[#\[\]]/g, "");
    let words = text.split(/\s+/);
    text = "";
    for (let word of words) {
      if (word) {
        text = `${text}${word[0].toUpperCase()}`;
        if (!first_letters) {
          let remainder = word.slice(1);
          if (remove_vowels) {
            remainder = remainder.replaceAll(/[aeiou]/g, "");
          }
          text = `${text}${remainder}`;
        }
      }
    }
    text = text.replaceAll(" ", "");
    return text;
  }
};

// main.ts
var DEBUG2 = true;
var ProjectTasks = class extends import_obsidian.Plugin {
  async onload() {
    if (DEBUG2)
      console.log("Project Tasks starting");
    await this.loadSettings();
    this.addCommand({
      id: "set-ids",
      name: "Set project ids on Selection",
      editorCallback: (editor, view) => {
        let sel = editor.getSelection();
        let lines = Helper.addTaskIDs(sel, Helper.getPrefix(editor, this.getFilename(view), this.settings), this.settings.automaticTagNames, this.settings.nestedTaskBehavior == "1" /* ParallelExecution */, this.settings.idPrefixMethod == "1" /* UsePrefix */, this.settings.randomIDLength, this.settings.sequentialStartNumber);
        editor.replaceSelection(
          `${lines}`
        );
      }
    });
    this.addCommand({
      id: "set-ids-block",
      name: "Set project ids on Block",
      editorCallback: (editor, view) => {
        Helper.blockUpdate(editor, this.getFilename(view), true, this.settings);
      }
    });
    this.addCommand({
      id: "add-project-task-list",
      name: "Add active project task list",
      editorCallback: (editor, view) => {
        this.addActiveProjectList(editor);
      }
    });
    this.addCommand({
      id: "clear-ids",
      name: "Clear project ids on Selection",
      editorCallback: (editor, view) => {
        let sel = editor.getSelection();
        let lines = Helper.clearBlockIDs(sel, this.settings.automaticTagNames, this.settings.clearAllTags);
        editor.replaceSelection(
          `${lines}`
        );
      }
    });
    this.addCommand({
      id: "clear-ids-block",
      name: "Clear project ids on Block",
      editorCallback: (editor, view) => {
        Helper.blockUpdate(editor, this.getFilename(view), false, this.settings);
      }
    });
    this.addCommand({
      id: "clear-ids-file",
      name: "Clear project ids in entire file",
      editorCallback: (editor, view) => {
        let last_line = editor.lineCount();
        let range_from = { line: 0, ch: 0 };
        let range_to = { line: last_line, ch: editor.getLine(last_line).length };
        let sel = editor.getRange(range_from, range_to);
        let lines = Helper.clearBlockIDs(sel, this.settings.automaticTagNames, this.settings.clearAllTags);
        editor.replaceRange(
          `${lines}`,
          range_from,
          range_to
        );
      }
    });
    this.addSettingTab(new ProjectTasksSettingsTab(this.app, this));
  }
  addActiveProjectList(editor) {
    const active_tasks_view = `\`\`\`tasks
tags includes #${this.settings.automaticTagNames}
not done
hide backlink
is not blocked
\`\`\``;
    editor.replaceSelection(active_tasks_view);
  }
  getFilename(view) {
    var _a;
    if (!((_a = view.file) == null ? void 0 : _a.name)) {
      return this.settings.projectPrefix;
    } else {
      return view.file.name.split(".")[0];
    }
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var ProjectTasksSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Project ID method").setDesc("Choose how the ID will be determined").addDropdown((dropDown) => {
      dropDown.addOption("1", "Use prefix");
      dropDown.addOption("2", "Use Section name");
      dropDown.addOption("3", "Use filename").setValue(this.plugin.settings.idPrefixMethod).onChange(async (value) => {
        this.plugin.settings.idPrefixMethod = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Project ID prefix").setDesc("Prefix to use when creating an ID for a task").addText((text) => text.setPlaceholder("ID prefix").setValue(this.plugin.settings.projectPrefix).onChange(async (value) => {
      this.plugin.settings.projectPrefix = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Length of random ID number").setDesc("How many digits to use for random ID when using a fixed prefix").addSlider((text) => text.setValue(this.plugin.settings.randomIDLength).setLimits(3, 6, 1).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.randomIDLength = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Initial sequential ID number").setDesc("Start number for sequential ID's").addSlider((text) => text.setValue(this.plugin.settings.sequentialStartNumber).setLimits(0, 1, 1).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.sequentialStartNumber = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Remove vowels").setDesc("Remove vowels from the prefix when getting from the filename or block name").addToggle((text) => text.setValue(this.plugin.settings.removeVowels).onChange(async (value) => {
      this.plugin.settings.removeVowels = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("First letter of words").setDesc("Only use the first letter of words to form the prefix").addToggle((text) => text.setValue(this.plugin.settings.firstLettersOfWords).onChange(async (value) => {
      this.plugin.settings.firstLettersOfWords = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Automatically add tags").setDesc("A list of tags (one per line) to add to each task - do not include the # symbol").addTextArea((text) => {
      text.setValue(this.plugin.settings.automaticTagNames.join("\n")).onChange((value) => {
        this.plugin.settings.automaticTagNames = value.split("\n").filter((line) => line.trim() !== "");
        this.plugin.saveSettings();
      }).then((textArea) => {
        textArea.inputEl.style.width = "100%";
        textArea.inputEl.rows = 5;
      });
    });
    new import_obsidian.Setting(containerEl).setName("Clear all tags from project tasks").setDesc("When clearing tags from project tasks clear all existing tags not just the automatically added ones").addToggle((text) => text.setValue(this.plugin.settings.clearAllTags).onChange(async (value) => {
      this.plugin.settings.clearAllTags = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Nested tags behaviour").setDesc("Determines whether nested tags will create parallel execution tags or sequential").addDropdown((dropDown) => {
      dropDown.addOption("1", "Parallel Execution");
      dropDown.addOption("2", "Sequential Execution").setValue(this.plugin.settings.nestedTaskBehavior).onChange(async (value) => {
        this.plugin.settings.nestedTaskBehavior = value;
        await this.plugin.saveSettings();
      });
    });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJoZWxwZXJzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQge0FwcCwgRWRpdG9yLCBNYXJrZG93bkZpbGVJbmZvLCBQbHVnaW4sIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmd9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBIZWxwZXIsIHtERUZBVUxUX1NFVFRJTkdTLCBOZXN0aW5nQmVoYXZpb3VyLCBQcmVmaXhNZXRob2QsIFByb2plY3RUYXNrc1NldHRpbmdzfSBmcm9tIFwiLi9oZWxwZXJzXCI7XG5cbi8vIFR1cm4gb24gdG8gYWxsb3cgZGVidWdnaW5nIGluIHRoZSBjb25zb2xlXG5jb25zdCBERUJVRyA9IHRydWU7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvamVjdFRhc2tzIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBzZXR0aW5nczogUHJvamVjdFRhc2tzU2V0dGluZ3M7XG5cbiAgICBhc3luYyBvbmxvYWQoKSB7XG4gICAgICAgIGlmIChERUJVRykgY29uc29sZS5sb2coJ1Byb2plY3QgVGFza3Mgc3RhcnRpbmcnKTtcblxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogXCJzZXQtaWRzXCIsXG4gICAgICAgICAgICBuYW1lOiBcIlNldCBwcm9qZWN0IGlkcyBvbiBTZWxlY3Rpb25cIixcbiAgICAgICAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yLCB2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBIZWxwZXIuYWRkVGFza0lEcyhzZWwsIEhlbHBlci5nZXRQcmVmaXgoZWRpdG9yLCB0aGlzLmdldEZpbGVuYW1lKHZpZXcpLCB0aGlzLnNldHRpbmdzKSwgdGhpcy5zZXR0aW5ncy5hdXRvbWF0aWNUYWdOYW1lcywgdGhpcy5zZXR0aW5ncy5uZXN0ZWRUYXNrQmVoYXZpb3IgPT0gTmVzdGluZ0JlaGF2aW91ci5QYXJhbGxlbEV4ZWN1dGlvbiwgdGhpcy5zZXR0aW5ncy5pZFByZWZpeE1ldGhvZCA9PSBQcmVmaXhNZXRob2QuVXNlUHJlZml4LCB0aGlzLnNldHRpbmdzLnJhbmRvbUlETGVuZ3RoLCB0aGlzLnNldHRpbmdzLnNlcXVlbnRpYWxTdGFydE51bWJlcik7XG4gICAgICAgICAgICAgICAgZWRpdG9yLnJlcGxhY2VTZWxlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgIGAke2xpbmVzfWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6IFwic2V0LWlkcy1ibG9ja1wiLFxuICAgICAgICAgICAgbmFtZTogXCJTZXQgcHJvamVjdCBpZHMgb24gQmxvY2tcIixcbiAgICAgICAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yLCB2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgSGVscGVyLmJsb2NrVXBkYXRlKGVkaXRvciwgdGhpcy5nZXRGaWxlbmFtZSh2aWV3KSwgdHJ1ZSwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6IFwiYWRkLXByb2plY3QtdGFzay1saXN0XCIsXG4gICAgICAgICAgICBuYW1lOiBcIkFkZCBhY3RpdmUgcHJvamVjdCB0YXNrIGxpc3RcIixcbiAgICAgICAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yLCB2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBY3RpdmVQcm9qZWN0TGlzdChlZGl0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogXCJjbGVhci1pZHNcIixcbiAgICAgICAgICAgIG5hbWU6IFwiQ2xlYXIgcHJvamVjdCBpZHMgb24gU2VsZWN0aW9uXCIsXG4gICAgICAgICAgICBlZGl0b3JDYWxsYmFjazogKGVkaXRvciwgdmlldykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gSGVscGVyLmNsZWFyQmxvY2tJRHMoc2VsLCB0aGlzLnNldHRpbmdzLmF1dG9tYXRpY1RhZ05hbWVzLCB0aGlzLnNldHRpbmdzLmNsZWFyQWxsVGFncyk7XG4gICAgICAgICAgICAgICAgZWRpdG9yLnJlcGxhY2VTZWxlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgIGAke2xpbmVzfWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6IFwiY2xlYXItaWRzLWJsb2NrXCIsXG4gICAgICAgICAgICBuYW1lOiBcIkNsZWFyIHByb2plY3QgaWRzIG9uIEJsb2NrXCIsXG4gICAgICAgICAgICBlZGl0b3JDYWxsYmFjazogKGVkaXRvciwgdmlldykgPT4ge1xuICAgICAgICAgICAgICAgIEhlbHBlci5ibG9ja1VwZGF0ZShlZGl0b3IsIHRoaXMuZ2V0RmlsZW5hbWUodmlldyksIGZhbHNlLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6IFwiY2xlYXItaWRzLWZpbGVcIixcbiAgICAgICAgICAgIG5hbWU6IFwiQ2xlYXIgcHJvamVjdCBpZHMgaW4gZW50aXJlIGZpbGVcIixcbiAgICAgICAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yLCB2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3RfbGluZSA9IGVkaXRvci5saW5lQ291bnQoKVxuICAgICAgICAgICAgICAgIGxldCByYW5nZV9mcm9tID0ge2xpbmU6IDAsIGNoOiAwfVxuICAgICAgICAgICAgICAgIGxldCByYW5nZV90byA9IHtsaW5lOiBsYXN0X2xpbmUsIGNoOiBlZGl0b3IuZ2V0TGluZShsYXN0X2xpbmUpLmxlbmd0aH1cbiAgICAgICAgICAgICAgICBsZXQgc2VsID0gZWRpdG9yLmdldFJhbmdlKHJhbmdlX2Zyb20sIHJhbmdlX3RvKTtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBIZWxwZXIuY2xlYXJCbG9ja0lEcyhzZWwsIHRoaXMuc2V0dGluZ3MuYXV0b21hdGljVGFnTmFtZXMsIHRoaXMuc2V0dGluZ3MuY2xlYXJBbGxUYWdzKTtcbiAgICAgICAgICAgICAgICBlZGl0b3IucmVwbGFjZVJhbmdlKFxuICAgICAgICAgICAgICAgICAgICBgJHtsaW5lc31gLFxuICAgICAgICAgICAgICAgICAgICByYW5nZV9mcm9tLFxuICAgICAgICAgICAgICAgICAgICByYW5nZV90b1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gVGhpcyBhZGRzIGEgc2V0dGluZ3MgdGFiIHNvIHRoZSB1c2VyIGNhbiBjb25maWd1cmUgdmFyaW91cyBhc3BlY3RzIG9mIHRoZSBwbHVnaW5cbiAgICAgICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBQcm9qZWN0VGFza3NTZXR0aW5nc1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXG4gICAgfVxuXG4gICAgYWRkQWN0aXZlUHJvamVjdExpc3QoZWRpdG9yOiBFZGl0b3IpIHtcbiAgICAgICAgLy8gQSB2aWV3IHRvIHNob3cgYWN0aXZlIHRhc2tzXG4gICAgICAgIGNvbnN0IGFjdGl2ZV90YXNrc192aWV3ID0gYFxcYFxcYFxcYHRhc2tzXG50YWdzIGluY2x1ZGVzICMke3RoaXMuc2V0dGluZ3MuYXV0b21hdGljVGFnTmFtZXN9XG5ub3QgZG9uZVxuaGlkZSBiYWNrbGlua1xuaXMgbm90IGJsb2NrZWRcblxcYFxcYFxcYGA7XG4gICAgICAgIGVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKGFjdGl2ZV90YXNrc192aWV3KTtcbiAgICB9XG5cblxuXG4gICAgZ2V0RmlsZW5hbWUodmlldzogTWFya2Rvd25GaWxlSW5mbykge1xuICAgICAgICBpZiAoIXZpZXcuZmlsZT8ubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MucHJvamVjdFByZWZpeDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3LmZpbGUubmFtZS5zcGxpdCgnLicpWzBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb251bmxvYWQoKSB7XG5cbiAgICB9XG5cbiAgICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICAgIH1cblxuICAgIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgICB9XG59XG5cblxuY2xhc3MgUHJvamVjdFRhc2tzU2V0dGluZ3NUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgICBwbHVnaW46IFByb2plY3RUYXNrcztcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IFByb2plY3RUYXNrcykge1xuICAgICAgICBzdXBlcihhcHAsIHBsdWdpbik7XG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgIH1cblxuICAgIGRpc3BsYXkoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnUHJvamVjdCBJRCBtZXRob2QnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0Nob29zZSBob3cgdGhlIElEIHdpbGwgYmUgZGV0ZXJtaW5lZCcpXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcERvd24gPT4ge1xuICAgICAgICAgICAgICAgIGRyb3BEb3duLmFkZE9wdGlvbignMScsICdVc2UgcHJlZml4Jyk7XG4gICAgICAgICAgICAgICAgZHJvcERvd24uYWRkT3B0aW9uKCcyJywgJ1VzZSBTZWN0aW9uIG5hbWUnKTtcbiAgICAgICAgICAgICAgICBkcm9wRG93bi5hZGRPcHRpb24oJzMnLCAnVXNlIGZpbGVuYW1lJylcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmlkUHJlZml4TWV0aG9kKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pZFByZWZpeE1ldGhvZCA9IHZhbHVlIGFzIFByZWZpeE1ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnUHJvamVjdCBJRCBwcmVmaXgnKVxuICAgICAgICAgICAgLnNldERlc2MoJ1ByZWZpeCB0byB1c2Ugd2hlbiBjcmVhdGluZyBhbiBJRCBmb3IgYSB0YXNrJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignSUQgcHJlZml4JylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvamVjdFByZWZpeClcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnByb2plY3RQcmVmaXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0xlbmd0aCBvZiByYW5kb20gSUQgbnVtYmVyJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdIb3cgbWFueSBkaWdpdHMgdG8gdXNlIGZvciByYW5kb20gSUQgd2hlbiB1c2luZyBhIGZpeGVkIHByZWZpeCcpXG4gICAgICAgICAgICAuYWRkU2xpZGVyKHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yYW5kb21JRExlbmd0aClcbiAgICAgICAgICAgICAgICAuc2V0TGltaXRzKDMsIDYsIDEpXG4gICAgICAgICAgICAgICAgLnNldER5bmFtaWNUb29sdGlwKClcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnJhbmRvbUlETGVuZ3RoID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdJbml0aWFsIHNlcXVlbnRpYWwgSUQgbnVtYmVyJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdTdGFydCBudW1iZXIgZm9yIHNlcXVlbnRpYWwgSURcXCdzJylcbiAgICAgICAgICAgIC5hZGRTbGlkZXIodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnNlcXVlbnRpYWxTdGFydE51bWJlcilcbiAgICAgICAgICAgICAgICAuc2V0TGltaXRzKDAsIDEsIDEpXG4gICAgICAgICAgICAgICAgLnNldER5bmFtaWNUb29sdGlwKClcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnNlcXVlbnRpYWxTdGFydE51bWJlciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnUmVtb3ZlIHZvd2VscycpXG4gICAgICAgICAgICAuc2V0RGVzYygnUmVtb3ZlIHZvd2VscyBmcm9tIHRoZSBwcmVmaXggd2hlbiBnZXR0aW5nIGZyb20gdGhlIGZpbGVuYW1lIG9yIGJsb2NrIG5hbWUnKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucmVtb3ZlVm93ZWxzKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucmVtb3ZlVm93ZWxzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdGaXJzdCBsZXR0ZXIgb2Ygd29yZHMnKVxuICAgICAgICAgICAgLnNldERlc2MoJ09ubHkgdXNlIHRoZSBmaXJzdCBsZXR0ZXIgb2Ygd29yZHMgdG8gZm9ybSB0aGUgcHJlZml4JylcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmZpcnN0TGV0dGVyc09mV29yZHMpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5maXJzdExldHRlcnNPZldvcmRzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0F1dG9tYXRpY2FsbHkgYWRkIHRhZ3MnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0EgbGlzdCBvZiB0YWdzIChvbmUgcGVyIGxpbmUpIHRvIGFkZCB0byBlYWNoIHRhc2sgLSBkbyBub3QgaW5jbHVkZSB0aGUgIyBzeW1ib2wnKVxuICAgICAgICAgICAgLmFkZFRleHRBcmVhKCh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdXRvbWF0aWNUYWdOYW1lcy5qb2luKCdcXG4nKSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuYXV0b21hdGljVGFnTmFtZXMgPSB2YWx1ZS5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4gbGluZS50cmltKCkgIT09ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKHRleHRBcmVhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFyZWEuaW5wdXRFbC5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QXJlYS5pbnB1dEVsLnJvd3MgPSA1O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnQ2xlYXIgYWxsIHRhZ3MgZnJvbSBwcm9qZWN0IHRhc2tzJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdXaGVuIGNsZWFyaW5nIHRhZ3MgZnJvbSBwcm9qZWN0IHRhc2tzIGNsZWFyIGFsbCBleGlzdGluZyB0YWdzIG5vdCBqdXN0IHRoZSBhdXRvbWF0aWNhbGx5IGFkZGVkIG9uZXMnKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuY2xlYXJBbGxUYWdzKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY2xlYXJBbGxUYWdzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdOZXN0ZWQgdGFncyBiZWhhdmlvdXInKVxuICAgICAgICAgICAgLnNldERlc2MoJ0RldGVybWluZXMgd2hldGhlciBuZXN0ZWQgdGFncyB3aWxsIGNyZWF0ZSBwYXJhbGxlbCBleGVjdXRpb24gdGFncyBvciBzZXF1ZW50aWFsJylcbiAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wRG93biA9PiB7XG4gICAgICAgICAgICAgICAgZHJvcERvd24uYWRkT3B0aW9uKCcxJywgJ1BhcmFsbGVsIEV4ZWN1dGlvbicpO1xuICAgICAgICAgICAgICAgIGRyb3BEb3duLmFkZE9wdGlvbignMicsICdTZXF1ZW50aWFsIEV4ZWN1dGlvbicpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5uZXN0ZWRUYXNrQmVoYXZpb3IpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm5lc3RlZFRhc2tCZWhhdmlvciA9IHZhbHVlIGFzIE5lc3RpbmdCZWhhdmlvdXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuXG5cblxuICAgIH1cbn1cblxuIiwgIi8vIFJlZ2V4IGZvciBibG9jayBib3VuZGFyeVxuaW1wb3J0IHtFZGl0b3IsIE1hcmtkb3duRmlsZUluZm99IGZyb20gXCJvYnNpZGlhblwiO1xuXG5jb25zdCBCTE9DS19CT1VOREFSWSA9IC9eIytcXHMvO1xuY29uc3QgREVCVUcgPSB0cnVlO1xuXG5cbmV4cG9ydCBlbnVtIFByZWZpeE1ldGhvZCB7XG4gICAgVXNlUHJlZml4ID0gJzEnLFxuICAgIFNlY3Rpb25OYW1lID0gJzInLFxuICAgIEZpbGVOYW1lID0gJzMnXG59XG5cbmV4cG9ydCBlbnVtIE5lc3RpbmdCZWhhdmlvdXIge1xuICAgIFBhcmFsbGVsRXhlY3V0aW9uID0gJzEnLFxuICAgIFNlcXVlbnRpYWxFeGVjdXRpb24gPSAnMicsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvamVjdFRhc2tzU2V0dGluZ3Mge1xuICAgIGlkUHJlZml4TWV0aG9kOiBQcmVmaXhNZXRob2Q7XG4gICAgcHJvamVjdFByZWZpeDogc3RyaW5nO1xuICAgIHJhbmRvbUlETGVuZ3RoOiBudW1iZXI7XG4gICAgc2VxdWVudGlhbFN0YXJ0TnVtYmVyOiBudW1iZXI7XG4gICAgcmVtb3ZlVm93ZWxzOiBib29sZWFuO1xuICAgIGZpcnN0TGV0dGVyc09mV29yZHM6IGJvb2xlYW47XG4gICAgYXV0b21hdGljVGFnTmFtZXM6IHN0cmluZ1tdO1xuICAgIGNsZWFyQWxsVGFnczogYm9vbGVhbjtcbiAgICBuZXN0ZWRUYXNrQmVoYXZpb3I6IE5lc3RpbmdCZWhhdmlvdXI7XG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBQcm9qZWN0VGFza3NTZXR0aW5ncyA9IHtcbiAgICBpZFByZWZpeE1ldGhvZDogUHJlZml4TWV0aG9kLlVzZVByZWZpeCxcbiAgICBwcm9qZWN0UHJlZml4OiAncHJqJyxcbiAgICByYW5kb21JRExlbmd0aDogNixcbiAgICBzZXF1ZW50aWFsU3RhcnROdW1iZXI6IDEsXG4gICAgcmVtb3ZlVm93ZWxzOiBmYWxzZSxcbiAgICBmaXJzdExldHRlcnNPZldvcmRzOiBmYWxzZSxcbiAgICBhdXRvbWF0aWNUYWdOYW1lczogW1wiUHJvamVjdFwiXSxcbiAgICBjbGVhckFsbFRhZ3M6IGZhbHNlLFxuICAgIG5lc3RlZFRhc2tCZWhhdmlvcjogTmVzdGluZ0JlaGF2aW91ci5QYXJhbGxlbEV4ZWN1dGlvbixcbn1cblxuaW50ZXJmYWNlIFNpbXBsZUN1cnNvciB7XG4gICAgbGluZTogbnVtYmVyXG4gICAgY2g6IG51bWJlclxufVxuXG5pbnRlcmZhY2UgU2ltcGxlRWRpdG9yIHtcbiAgICAvLyBUaGlzIGludGVyZmFjZSBpcyBjcmVhdGVkIHRvIGhlbHAgd2l0aCB0aGUgZnVuY3Rpb25zIGhlcmUgdGhhdCBuZWVkIHRoZSBPYnNpZGlhbiBFZGl0b3JcbiAgICBnZXRDdXJzb3IoKTogU2ltcGxlQ3Vyc29yO1xuICAgIGdldExpbmUobjogbnVtYmVyKTogc3RyaW5nO1xuICAgIGxpbmVDb3VudCgpOiBudW1iZXI7XG4gICAgZ2V0UmFuZ2Uoc3RhcnQ6IHtsaW5lOiBudW1iZXIsIGNoOiBudW1iZXJ9LCBlbmQ6IHtsaW5lOiBudW1iZXIsIGNoOiBudW1iZXJ9KTogc3RyaW5nO1xuICAgIHJlcGxhY2VSYW5nZSh0ZXh0OiBzdHJpbmcsIHN0YXJ0OiB7bGluZTogbnVtYmVyLCBjaDogbnVtYmVyfSwgZW5kOiB7bGluZTogbnVtYmVyLCBjaDogbnVtYmVyfSk6IHZvaWQ7XG4gICAgc2V0Q3Vyc29yKGN1cnNvcjoge2xpbmU6IG51bWJlciwgY2g6IG51bWJlcn0pOiB2b2lkO1xufVxuXG5cbmNsYXNzIFBhcnNlZExpbmUge1xuICAgIHB1YmxpYyB0YXNrX3ByZWZpeDogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGlzX3Rhc2s6IGJvb2xlYW4sIHB1YmxpYyBzdGF0dXNfdHlwZTogc3RyaW5nLCBwdWJsaWMgbGluZV90ZXh0OiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgcHVibGljIG5lc3Rpbmc6IG51bWJlcikge1xuICAgICAgICBpZiAodGhpcy5pc190YXNrKSB7XG4gICAgICAgICAgICBsZXQgaW5kZW50cyA9ICdcXHQnLnJlcGVhdChuZXN0aW5nKTtcbiAgICAgICAgICAgIHRoaXMudGFza19wcmVmaXggPSBgJHtpbmRlbnRzfS0gWyR7c3RhdHVzX3R5cGV9XSBgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50YXNrX3ByZWZpeCA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0TGluZVNwbGl0KGxpbmU6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gbGluZS5zcGxpdCgvKFxccyspLyk7XG4gICAgfVxuXG4gICAgcmVtb3ZlQWxsVGFncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlVGFncygpO1xuICAgIH1cblxuICAgIHJlbW92ZVRhZ3ModGFnc190b19yZW1vdmU/OiBzdHJpbmdbXSkge1xuICAgICAgICBsZXQgd29yZHMgPSB0aGlzLmdldExpbmVTcGxpdCh0aGlzLmxpbmVfdGV4dCk7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHdvcmRzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGxldCB3b3JkID0gd29yZHNbaWR4XTtcbiAgICAgICAgICAgIGlmICh3b3JkLnRyaW0oKS5sZW5ndGggIT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEl0IGlzIGEgdmFsaWQgdGFnIHdlIHNob3VsZCBiZSByZW1vdmluZ1xuICAgICAgICAgICAgICAgIGxldCBpc192YWxpZF90YWcgPSB3b3JkLnN0YXJ0c1dpdGgoJyMnKSAmJiAoIXRhZ3NfdG9fcmVtb3ZlIHx8IHRhZ3NfdG9fcmVtb3ZlLmluZGV4T2Yod29yZC5zbGljZSgxKSkgPj0gMClcbiAgICAgICAgICAgICAgICBpZiAoaXNfdmFsaWRfdGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IGlzIGEgdGFnLCBzbyBkbyBub3QgaW5jbHVkZSBpdCBhbmQgZWF0IHRoZSBwcmV2aW91cyBvciBmb2xsb3dpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICB3b3Jkc1tpZHhdID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHggIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29yZHNbaWR4IC0gMV0gPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpZHggIT0gd29yZHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29yZHNbaWR4ICsgMV0gPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3YXMgd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgIGlmIChpZHggPT0gd29yZHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgaWdub3JlIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgd29yZHNbaWR4XSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd29yZHMuam9pbignJyk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWxwZXIge1xuICAgIC8vIFNpbXBsZSBoZWxwZXIgY2xhc3MgdGhhdCBjb250YWlucyB0aGUgYnVzaW5lc3MgbG9naWNcbiAgICAvLyBvZiB0aGUgYXBwLiBUaGlzIGlzIGV4dHJhY3RlZCBoZXJlIHRvIGFsbG93IHVuaXQgdGVzdGluZ1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXROZXN0aW5nTGV2ZWwodGFza19tYXJrZXI6IHN0cmluZyk6IG51bWJlciB7XG4gICAgICAgIC8vIFRoZSBuZXN0aW5nIGxldmVsIGlzIHRoZSBudW1iZXIgb2Ygc3BhY2VzIGJlZm9yZSB0aGUgZmlyc3QgXCItXCIgY2hhcmFjdGVyXG4gICAgICAgIGxldCBwYXJ0cyA9IHRhc2tfbWFya2VyLnJlcGxhY2VBbGwoXCJcXG5cIiwgXCJcIikuc3BsaXQoXCItXCIpO1xuICAgICAgICByZXR1cm4gcGFydHNbMF0ubGVuZ3RoO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZW5lcmF0ZVJhbmRvbURpZ2l0cyhsZW5ndGg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgICBjb25zdCBkaWdpdHMgPSAnMDEyMzQ1Njc4OSc7XG4gICAgICBsZXQgcmFuZG9tU3RyaW5nID0gJyc7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBkaWdpdHMubGVuZ3RoKTtcbiAgICAgICAgcmFuZG9tU3RyaW5nICs9IGRpZ2l0c1tyYW5kb21JbmRleF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByYW5kb21TdHJpbmc7XG4gICAgfVxuXG4gICAgc3RhdGljIGNsZWFyQmxvY2tJRHMoc2VsOiBzdHJpbmcsIGF1dG9tYXRpY190YWdzOiBzdHJpbmdbXSwgY2xlYXJfYWxsX3RhZ3M6IGJvb2xlYW4pIHtcbiAgICAgICAgLy8gUmVtb3ZlIGV4aXN0aW5nIElEJ3NcbiAgICAgICAgbGV0IHJlbW92ZV9pZCA9IC9cdUQ4M0NcdUREOTRcXHNbXFx3LF0rWyBcXHRdKi9nO1xuICAgICAgICBzZWwgPSBzZWwucmVwbGFjZUFsbChyZW1vdmVfaWQsICcnKTtcblxuICAgICAgICAvLyBSZW1vdmUgZXhpc3RpbmcgQmxvY2tzXG4gICAgICAgIGxldCByZW1vdmVfYmxvY2sgPSAvXHUyNkQ0XFxzW1xcdyxdK1sgXFx0XSovZztcbiAgICAgICAgc2VsID0gc2VsLnJlcGxhY2VBbGwocmVtb3ZlX2Jsb2NrLCAnJyk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSB0YWdzXG4gICAgICAgIGxldCBjbGVhbmVkX3RleHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiBzZWwuc3BsaXQoL1xccj9cXG4vKSkge1xuICAgICAgICAgICAgbGV0IHBhcnNlZCA9IHRoaXMucGFyc2VMaW5lKGxpbmUpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZC5pc190YXNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsZWFyX2FsbF90YWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuZWRfdGV4dC5wdXNoKHBhcnNlZC50YXNrX3ByZWZpeCArIHBhcnNlZC5yZW1vdmVBbGxUYWdzKCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuZWRfdGV4dC5wdXNoKHBhcnNlZC50YXNrX3ByZWZpeCArIHBhcnNlZC5yZW1vdmVUYWdzKGF1dG9tYXRpY190YWdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGVhbmVkX3RleHQucHVzaChwYXJzZWQubGluZV90ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbGVhbmVkX3RleHQuam9pbignXFxuJyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldEJsb2NrRW5kKGVkaXRvcjogU2ltcGxlRWRpdG9yKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGVuZCBvZiB0aGUgYmxvY2tcbiAgICAgICAgbGV0IGJsb2NrRW5kID0gZWRpdG9yLmdldEN1cnNvcigpLmxpbmU7XG4gICAgICAgIGlmIChibG9ja0VuZCA+PSBlZGl0b3IubGluZUNvdW50KCkgLSAxKSByZXR1cm4gYmxvY2tFbmQgKyAxO1xuICAgICAgICBibG9ja0VuZCArPSAxO1xuICAgICAgICB3aGlsZSAoIUJMT0NLX0JPVU5EQVJZLnRlc3QoZWRpdG9yLmdldExpbmUoYmxvY2tFbmQpKSkge1xuICAgICAgICAgICAgYmxvY2tFbmQrKztcbiAgICAgICAgICAgIGlmIChibG9ja0VuZCA+IGVkaXRvci5saW5lQ291bnQoKSAtIDEpIHJldHVybiBibG9ja0VuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2tFbmQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldEJsb2NrU3RhcnQoZWRpdG9yOiBTaW1wbGVFZGl0b3IpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgc3RhcnQgb2YgdGhlIGJsb2NrXG4gICAgICAgIGxldCBibG9ja1N0YXJ0ID0gZWRpdG9yLmdldEN1cnNvcigpLmxpbmU7XG4gICAgICAgIGlmIChCTE9DS19CT1VOREFSWS50ZXN0KGVkaXRvci5nZXRMaW5lKGJsb2NrU3RhcnQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKGVkaXRvci5saW5lQ291bnQoKSAtMSwgYmxvY2tTdGFydCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChibG9ja1N0YXJ0ID4gMCAmJiAhQkxPQ0tfQk9VTkRBUlkudGVzdChlZGl0b3IuZ2V0TGluZShibG9ja1N0YXJ0IC0gMSkpKSB7XG4gICAgICAgICAgICBibG9ja1N0YXJ0LS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrU3RhcnQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldEFsbEJsb2NrU3RhcnRzKGVkaXRvcjogU2ltcGxlRWRpdG9yKSB7XG4gICAgICAgIC8vIFJldHVybiBhbGwgdGhlIGxpbmVzIHRoYXQgbWFyayB0aGUgc3RhcnQgb2YgYSBibG9jayBpbiBhIGZpbGVcbiAgICAgICAgbGV0IGJsb2NrcyA9IFswXTtcbiAgICAgICAgbGV0IHNlY3Rpb24gPSAvXiM/XFxzXFx3Ky9cbiAgICAgICAgZm9yIChsZXQgbGluZV9udW1iZXIgPSAwOyBsaW5lX251bWJlciA8IGVkaXRvci5saW5lQ291bnQoKTsgbGluZV9udW1iZXIrKykge1xuICAgICAgICAgICAgaWYgKHNlY3Rpb24udGVzdChlZGl0b3IuZ2V0TGluZShsaW5lX251bWJlcikpKSB7XG4gICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHdoZW4gdGhlIGZpcnN0IGxpbmUgaXMgYSBzZWN0aW9uIHdlIGRvbid0IGhhdmUgdG8gYWRkIGl0XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVfbnVtYmVyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja3MucHVzaChsaW5lX251bWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJsb2NrcztcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0U2VjdGlvbk5hbWUoZWRpdG9yOiBTaW1wbGVFZGl0b3IsIGZpbGVfbmFtZTogc3RyaW5nKSB7XG4gICAgICAgIGxldCBzZWN0aW9uX3N0YXJ0ID0gSGVscGVyLmdldEJsb2NrU3RhcnQoZWRpdG9yKTtcbiAgICAgICAgaWYgKHNlY3Rpb25fc3RhcnQgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbGVfbmFtZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVkaXRvci5nZXRMaW5lKHNlY3Rpb25fc3RhcnQtMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgYWRkVGFza0lEcyhzZWw6IHN0cmluZywgcHJlZml4OiBzdHJpbmcsIGF1dG9tYXRpY190YWdzOiBzdHJpbmdbXSwgcGFyYWxsZWw6IGJvb2xlYW4sIHVzZV9wcmVmaXg6IGJvb2xlYW4sXG4gICAgICAgICAgICAgICAgICAgICAgcmFuZG9tX2lkX2xlbmd0aDogbnVtYmVyLCBzZXF1ZW50aWFsX3N0YXJ0OiBudW1iZXIpIHtcbiAgICAgICAgLy8gQ2xlYXIgYWxsIHRoZSBleGlzdGluZyBibG9jayBhbmQgcHJvamVjdCBJRCdzXG4gICAgICAgIHNlbCA9IEhlbHBlci5jbGVhckJsb2NrSURzKHNlbCwgYXV0b21hdGljX3RhZ3MsIGZhbHNlKTtcblxuICAgICAgICBpZiAoREVCVUcpIGNvbnNvbGUubG9nKGBSZXBsYWNlZCBpZHMgYW5kIGJsb2NrcyB0byBnaXZlOiAke3NlbH1gKTtcblxuICAgICAgICBsZXQgbGluZXMgPSBcIlwiO1xuICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgICBsZXQgaWR4ID0gMDtcbiAgICAgICAgbGV0IG5lc3RpbmdfaWRzID0gW1wiMDpFUlJPUiFcIl07XG4gICAgICAgIGxldCBjdXJyZW50X25lc3RpbmcgPSAwO1xuICAgICAgICBsZXQgaXNfcGFyYWxsZWwgPSBmYWxzZTtcbiAgICAgICAgbGV0IHRoaXNfaWQ7XG5cbiAgICAgICAgLy8gR28gdGhyb3VnaCBhbGwgdGhlIGxpbmVzIGFuZCBhZGQgYXBwcm9wcmlhdGUgSUQgYW5kIGJsb2NrIHRhZ3NcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHNlbC5zcGxpdCgvXFxyP1xcbi8pKSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnBhcnNlTGluZShsaW5lKTtcbiAgICAgICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAgICAgICBsaW5lcyArPSBcIlxcblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSXMgdGhpcyBhIHRhc2sgbGluZSBhdCBhbGw/XG4gICAgICAgICAgICBpZiAobWF0Y2guaXNfdGFzaykge1xuICAgICAgICAgICAgICAgIC8vIFdhdGNoIG91dCBmb3IgY2hhbmdlcyBpbiBuZXN0aW5nXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFsbGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXN0aW5nX2RlcHRoID0gbWF0Y2gubmVzdGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lc3RpbmdfZGVwdGggPiBjdXJyZW50X25lc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBhIG5ldyBsZXZlbCBvZiBuZXN0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25lc3RpbmcgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzX3BhcmFsbGVsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lc3RpbmdfaWRzLnB1c2goYGApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5lc3RpbmdfZGVwdGggPCBjdXJyZW50X25lc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBsZXZlbHMgb2YgbmVzdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRfbmVzdGluZyA+IG5lc3RpbmdfZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25lc3RpbmcgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmVzdGVkID0gbmVzdGluZ19pZHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lc3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXN0aW5nX2lkc1tuZXN0aW5nX2lkcy5sZW5ndGggLSAxXSArPSBgLCR7bmVzdGVkfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzX3BhcmFsbGVsID0gY3VycmVudF9uZXN0aW5nID4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgdGhpc19saW5lO1xuICAgICAgICAgICAgICAgIC8vIEdldCBhbiBpZCB0byB1c2VcbiAgICAgICAgICAgICAgICBpZiAodXNlX3ByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzX2lkID0gYCR7cHJlZml4fSR7SGVscGVyLmdlbmVyYXRlUmFuZG9tRGlnaXRzKHJhbmRvbV9pZF9sZW5ndGgpfWA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc19pZCA9IGAke3ByZWZpeH0ke2lkeCArIHNlcXVlbnRpYWxfc3RhcnR9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBpZCBpbnRvIHRoZXJlXG4gICAgICAgICAgICAgICAgbGV0IGNsZWFuZWRfbGluZSA9IG1hdGNoLmxpbmVfdGV4dDtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBzcGFjZSBhdCB0aGUgZW5kIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmIChjbGVhbmVkX2xpbmUgIT0gXCJcIikgY2xlYW5lZF9saW5lICs9IFwiIFwiO1xuICAgICAgICAgICAgICAgIHRoaXNfbGluZSA9IGAke21hdGNoLnRhc2tfcHJlZml4fSR7Y2xlYW5lZF9saW5lfVx1RDgzQ1x1REQ5NCAke3RoaXNfaWR9YDtcbiAgICAgICAgICAgICAgICBpZiAoaWR4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGJsb2NrcyBhZnRlciB0aGUgdmVyeSBmaXJzdCB0YXNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc19wYXJhbGxlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc19saW5lICs9IGAgXHUyNkQ0ICR7bmVzdGluZ19pZHNbY3VycmVudF9uZXN0aW5nIC0gMV19YDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfbGluZSArPSBgIFx1MjZENCAke25lc3RpbmdfaWRzW25lc3RpbmdfaWRzLmxlbmd0aCAtIDFdfWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYW4gYXV0b21hdGljIHRhZyBpZiB3ZSBuZWVkIGl0XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0YWcgb2YgYXV0b21hdGljX3RhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhZ190ZXh0ID0gYCAjJHt0YWd9YDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNfbGluZS5pbmRleE9mKHRhZ190ZXh0KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfbGluZSArPSB0YWdfdGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGlzIGxpbmVcbiAgICAgICAgICAgICAgICBsaW5lcyArPSB0aGlzX2xpbmU7XG4gICAgICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGlzX3BhcmFsbGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXN0aW5nX2lkc1tuZXN0aW5nX2lkcy5sZW5ndGggLSAxXSkgbmVzdGluZ19pZHNbbmVzdGluZ19pZHMubGVuZ3RoIC0gMV0gKz0gXCIsXCI7XG4gICAgICAgICAgICAgICAgICAgIG5lc3RpbmdfaWRzW25lc3RpbmdfaWRzLmxlbmd0aCAtIDFdICs9IGAke3RoaXNfaWR9YDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXN0aW5nX2lkc1tuZXN0aW5nX2lkcy5sZW5ndGggLSAxXSA9IHRoaXNfaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChERUJVRykgY29uc29sZS5sb2coYE5lc3RpbmcgbGV2ZWwgJHtjdXJyZW50X25lc3Rpbmd9LCBpZHMgJHtuZXN0aW5nX2lkc31gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm90IGEgdGFzayBsaW5lIHNvIGp1c3Qga2VlcCBpdCBhcyBpc1xuICAgICAgICAgICAgICAgIGxpbmVzICs9IG1hdGNoLmxpbmVfdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cblxuICAgIHN0YXRpYyBibG9ja1VwZGF0ZShlZGl0b3I6IFNpbXBsZUVkaXRvciwgZmlsZW5hbWU6IHN0cmluZywgYWRkX2lkczogYm9vbGVhbiwgc2V0dGluZ3M6IFByb2plY3RUYXNrc1NldHRpbmdzLCkge1xuICAgICAgICBjb25zdCBwcmVmaXggPSB0aGlzLmdldFByZWZpeChlZGl0b3IsIGZpbGVuYW1lLCBzZXR0aW5ncyk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShlZGl0b3IuZ2V0Q3Vyc29yKCkubGluZSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBibG9jayBib3VuZGFyaWVzXG4gICAgICAgIGxldCBibG9ja1N0YXJ0ID0gSGVscGVyLmdldEJsb2NrU3RhcnQoZWRpdG9yKTtcbiAgICAgICAgbGV0IGJsb2NrRW5kID0gSGVscGVyLmdldEJsb2NrRW5kKGVkaXRvcik7XG4gICAgICAgIGxldCBsYXN0X2xpbmVfbGVuZ3RoID0gZWRpdG9yLmdldExpbmUoYmxvY2tFbmQgKyAxKS5sZW5ndGg7XG5cbiAgICAgICAgY29uc3QgYmxvY2tDb250ZW50ID0gZWRpdG9yLmdldFJhbmdlKHtsaW5lOiBibG9ja1N0YXJ0LCBjaDogMH0sIHtsaW5lOiBibG9ja0VuZCwgY2g6IGxhc3RfbGluZV9sZW5ndGh9KTtcbiAgICAgICAgaWYgKERFQlVHKSBjb25zb2xlLmxvZyhgU3RhcnQgJHtibG9ja1N0YXJ0fSwgRW5kICR7YmxvY2tFbmR9LCBsYXN0IGxlbmd0aCAke2xhc3RfbGluZV9sZW5ndGh9XFxuT3JpZzogJHtibG9ja0NvbnRlbnR9YCk7XG5cbiAgICAgICAgbGV0IGxpbmVzO1xuICAgICAgICBpZiAoYWRkX2lkcykge1xuICAgICAgICAgICAgbGluZXMgPSBIZWxwZXIuYWRkVGFza0lEcyhibG9ja0NvbnRlbnQsIHByZWZpeCwgc2V0dGluZ3MuYXV0b21hdGljVGFnTmFtZXMsXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MubmVzdGVkVGFza0JlaGF2aW9yID09IE5lc3RpbmdCZWhhdmlvdXIuUGFyYWxsZWxFeGVjdXRpb24sXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuaWRQcmVmaXhNZXRob2QgPT0gUHJlZml4TWV0aG9kLlVzZVByZWZpeCxcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYW5kb21JRExlbmd0aCwgc2V0dGluZ3Muc2VxdWVudGlhbFN0YXJ0TnVtYmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZXMgPSBIZWxwZXIuY2xlYXJCbG9ja0lEcyhibG9ja0NvbnRlbnQsIHNldHRpbmdzLmF1dG9tYXRpY1RhZ05hbWVzLFxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmNsZWFyQWxsVGFncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoREVCVUcpIGNvbnNvbGUubG9nKGBTdGFydCAke2Jsb2NrU3RhcnR9LCBFbmQgJHtibG9ja0VuZH0sIGxhc3QgbGVuZ3RoICR7bGFzdF9saW5lX2xlbmd0aH1cXG5PcmlnOiAke2Jsb2NrQ29udGVudH1cXG5OZXc6ICR7bGluZXN9YCk7XG4gICAgICAgIGVkaXRvci5yZXBsYWNlUmFuZ2UobGluZXMsIHtsaW5lOiBibG9ja1N0YXJ0LCBjaDogMH0sIHtsaW5lOiBibG9ja0VuZCwgY2g6IGxhc3RfbGluZV9sZW5ndGh9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0RW50aXJlQ29udmVydGVkRmlsZShlZGl0b3I6IFNpbXBsZUVkaXRvciwgZmlsZW5hbWU6IHN0cmluZywgc2V0dGluZ3M6IFByb2plY3RUYXNrc1NldHRpbmdzKSB7XG4gICAgICAgIGxldCBpbml0aWFsX2N1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKVxuICAgICAgICBmb3IgKGxldCBibG9ja19zdGFydCBvZiB0aGlzLmdldEFsbEJsb2NrU3RhcnRzKGVkaXRvcikpIHtcbiAgICAgICAgICAgIGVkaXRvci5zZXRDdXJzb3Ioe2xpbmU6IGJsb2NrX3N0YXJ0LCBjaDogMH0pO1xuICAgICAgICAgICAgdGhpcy5ibG9ja1VwZGF0ZShlZGl0b3IsIGZpbGVuYW1lLCB0cnVlLCBzZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yLnNldEN1cnNvcih7bGluZTogaW5pdGlhbF9jdXJzb3IubGluZSwgY2g6IGluaXRpYWxfY3Vyc29yLmNofSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlTGluZShsaW5lOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgcmVnZXggPSAvXihcXHMqLVxcc1xcWyhbIHhcXC1cXC9dKVxcXVxccyk/KC4qKSQvO1xuICAgICAgICBsZXQgbWF0Y2ggPSByZWdleC5leGVjKGxpbmUpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIFdhcyBhbiBleHBlY3RlZCBsaW5lXG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgdGFzayBsaW5lXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZWRMaW5lKHRydWUsIG1hdGNoWzJdLCBtYXRjaFszXSwgdGhpcy5nZXROZXN0aW5nTGV2ZWwobGluZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzbid0IGEgdGFzayBsaW5lXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZWRMaW5lKGZhbHNlLCAnJywgbWF0Y2hbM10sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmcgaGVyZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5lIHdhcyBub3QgdW5kZXJzdG9vZDogXCIke2xpbmV9XCJgKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgc3RhdGljIGdldFByZWZpeChlZGl0b3I6IFNpbXBsZUVkaXRvciwgZmlsZW5hbWU6IHN0cmluZywgc2V0dGluZ3M6IFByb2plY3RUYXNrc1NldHRpbmdzKSB7XG4gICAgICAgIGxldCByYXdfcHJlZml4O1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLmlkUHJlZml4TWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIFByZWZpeE1ldGhvZC5Vc2VQcmVmaXg6IHtcbiAgICAgICAgICAgICAgICByYXdfcHJlZml4ID0gc2V0dGluZ3MucHJvamVjdFByZWZpeDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgUHJlZml4TWV0aG9kLkZpbGVOYW1lOiB7XG4gICAgICAgICAgICAgICAgcmF3X3ByZWZpeCA9IGZpbGVuYW1lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBQcmVmaXhNZXRob2QuU2VjdGlvbk5hbWU6IHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZmluZCB0aGUgbmFtZSBvZiB0aGUgYmxvY2sgdGhhdCBjb250YWlucyB0aGUgY3Vyc29yIG9yIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICByYXdfcHJlZml4ID0gSGVscGVyLmdldFNlY3Rpb25OYW1lKGVkaXRvciwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBIZWxwZXIuZ2V0UHJlZml4RnJvbVN0cmluZyhyYXdfcHJlZml4LCBzZXR0aW5ncy5maXJzdExldHRlcnNPZldvcmRzLCBzZXR0aW5ncy5yZW1vdmVWb3dlbHMpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRQcmVmaXhGcm9tU3RyaW5nKHRleHQ6IHN0cmluZywgZmlyc3RfbGV0dGVyczogYm9vbGVhbiwgcmVtb3ZlX3Zvd2VsczogYm9vbGVhbikge1xuICAgICAgICAvLyBSZW1vdmUgYW55IHNwZWNpYWwgc2lnbnNcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbCgvWyNcXFtcXF1dL2csICcnKTtcbiAgICAgICAgLy8gQnJlYWsgaW50byB3b3Jkc1xuICAgICAgICBsZXQgd29yZHMgPSB0ZXh0LnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIHRleHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCB3b3JkIG9mIHdvcmRzKSB7XG4gICAgICAgICAgICBpZiAod29yZCkge1xuICAgICAgICAgICAgICAgIHRleHQgPSBgJHt0ZXh0fSR7d29yZFswXS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdF9sZXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZW1haW5kZXIgPSB3b3JkLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdm93ZWxzIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlX3Zvd2Vscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluZGVyID0gcmVtYWluZGVyLnJlcGxhY2VBbGwoL1thZWlvdV0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSBgJHt0ZXh0fSR7cmVtYWluZGVyfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSBzcGFjZXNcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbCgnICcsICcnKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUErRTs7O0FDRy9FLElBQU0saUJBQWlCO0FBQ3ZCLElBQU0sUUFBUTtBQTBCUCxJQUFNLG1CQUF5QztBQUFBLEVBQ2xELGdCQUFnQjtBQUFBLEVBQ2hCLGVBQWU7QUFBQSxFQUNmLGdCQUFnQjtBQUFBLEVBQ2hCLHVCQUF1QjtBQUFBLEVBQ3ZCLGNBQWM7QUFBQSxFQUNkLHFCQUFxQjtBQUFBLEVBQ3JCLG1CQUFtQixDQUFDLFNBQVM7QUFBQSxFQUM3QixjQUFjO0FBQUEsRUFDZCxvQkFBb0I7QUFDeEI7QUFrQkEsSUFBTSxhQUFOLE1BQWlCO0FBQUEsRUFHYixZQUFtQixTQUF5QixhQUE0QixXQUNyRCxTQUFpQjtBQURqQjtBQUF5QjtBQUE0QjtBQUNyRDtBQUNmLFFBQUksS0FBSyxTQUFTO0FBQ2QsVUFBSSxVQUFVLElBQUssT0FBTyxPQUFPO0FBQ2pDLFdBQUssY0FBYyxHQUFHLGFBQWE7QUFBQSxJQUN2QyxPQUFPO0FBQ0gsV0FBSyxjQUFjO0FBQUEsSUFDdkI7QUFBQSxFQUNKO0FBQUEsRUFFQSxhQUFhLE1BQWM7QUFDdkIsV0FBTyxLQUFLLE1BQU0sT0FBTztBQUFBLEVBQzdCO0FBQUEsRUFFQSxnQkFBZ0I7QUFDWixXQUFPLEtBQUssV0FBVztBQUFBLEVBQzNCO0FBQUEsRUFFQSxXQUFXLGdC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
